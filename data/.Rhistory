n3
n15
n30
plot(n3$zn, n3$Fbin)
plot(n3$zn, n3$Fbin, type = 's')
plot(n3$zn, n3$Fbin, type = 's')
plot(n3$zn, n3$Fbin, type = 's')
plot(n3$zn, n3$Fbin, type = 's')
points(n15$zn, n15$Fbin, type = 's')
points(n30$zn, n30$Fbin, type = 's')
plot(n3$zn, n3$Fbin, type = 's')
points(n15$zn, n15$Fbin, type = 's')
points(n30$zn, n30$Fbin, type = 's')
curve(pnorm, from = -2, to = 1.5)
plot(n3$zn, n3$Fbin, type = 's')
points(n15$zn, n15$Fbin, type = 's')
points(n30$zn, n30$Fbin, type = 's')
curve(pnorm, from = -2, to = 1.5)
plot(n3$zn, n3$Fbin, type = 's')
points(n15$zn, n15$Fbin, type = 's')
points(n30$zn, n30$Fbin, type = 's')
points(curve(pnorm, from = -2, to = 1.5))
lines(pnorm, from = -2, to = 1.5)
lines(x, type = 's')
x_n <- seq(from = -3, to = 3)
pnorm(x_n, 0, 1)
x_n1 <- pnorm(x_n, 0, 1)
lines(x_n1, type = 's')
lines(x_n1, y = NULL, type = 's')
lines(x_n, x_n1, type = 's')
plot(n3$zn, n3$Fbin, type = 's')
x_n <- seq(-2:2)
x_n
x_n <- seq(-200:200)/50
x_n
points(x_n, pnorm(x_n, 0, 1), type = 's')
plot(n3$zn, n3$Fbin, type = 's')
points(n15$zn, n15$Fbin, type = 's')
points(n30$zn, n30$Fbin, type = 's')
points(x_n, pnorm(x_n, 0, 1), type = 's')
x_n <- seq(-200:200)
x_n
x_n <- seq(-2, 2, 0.001)
x_n
plot(n3$zn, n3$Fbin, type = 's')
points(n15$zn, n15$Fbin, type = 's')
points(n30$zn, n30$Fbin, type = 's')
points(x_n, pnorm(x_n, 0, 1), type = 's')
# load packages here
library(tidyverse)
# read in data
df <- read_csv('state_of_utah.csv')
head(df)
df['81-90'] <- df %>%
mutate(sum = rowSums(across(c(`1981`, `1982`, `1983`, `1984`, `1985`, `1986`, `1987`, `1988`, `1989`, `1990`))))
df %>%
mutate(sum = rowSums(across(c(`1981`, `1982`, `1983`, `1984`, `1985`, `1986`, `1987`, `1988`, `1989`, `1990`))))
df[,'81-90'] <- df[,54]
df[,54]
df[54]
df[, 54]
df[, 12]
df
df[,'81-90'] <- df %>%
mutate(sum = rowSums(across(c(`1981`, `1982`, `1983`, `1984`, `1985`, `1986`, `1987`, `1988`, `1989`, `1990`))))
df1 <- df %>%
mutate(sum = rowSums(across(c(`1981`, `1982`, `1983`, `1984`, `1985`, `1986`, `1987`, `1988`, `1989`, `1990`))))
df[,'81-90'] <- df1[, 54]
df
df2 <- df %>%
mutate(sum = rowSums(across(c(`1991`, `1992`, `1993`, `1994`, `1995`, `1996`, `1997`, `1998`, `1999`, `2000`))))
df[, '91-2000'] <- df2[, 54]
df
# load packages here
library(tidyverse)
# read in data
df <- read_csv('state_of_utah.csv')
# head(df)
df1 <- df %>%
mutate(sum = rowSums(across(c(`1981`, `1982`, `1983`, `1984`, `1985`, `1986`, `1987`, `1988`, `1989`, `1990`))))
df[,'81-90'] <- df1[, 54]
df2 <- df %>%
mutate(sum = rowSums(across(c(`1991`, `1992`, `1993`, `1994`, `1995`, `1996`, `1997`, `1998`, `1999`, `2000`))))
df[, '91-2000'] <- df2[, 54]
df3 <- df %>%
mutate(sum = rowSums(across(c(`2001`, `2002`, `2003`, `2004`, `2005`, `2006`, `2007`, `2008`, `2009`, `2010`))))
df[, '01-2010'] <- df3[, 54]
df4 <- df %>%
mutate(sum = rowSums(across(c(`2011`, `2012`, `2013`, `2014`, `2015`, `2016`, `2017`, `2018`, `2019`, `2020`))))
df[, '11-2020'] <- df2[, 54]
head(df)
# 1a
#define range
p = seq(0, 1, length=100)
#create plot of Beta distribution with shape parameters
plot(p, dbeta(p, 6, 4), type='l')
# 1d
qbeta(.025, 83, 27)
qbeta(.975, 83, 27)
#create plot of Beta distribution with shape parameters
plot1 <- plot(p, dbeta(p, 6, 4), type='l')
#create plot of Beta distribution with shape parameters
plot1 <- plot(p, dbeta(p, 6, 4), type='l')
# 1e
plot1
# 1e
plot(p, dbeta(p, 83, 27), type='l')
# 1e
plot(p, dbeta(p, 83, 27), type='l')
plot(p, dbeta(p, 83, 27), type='l')
abline(v = .7545)
abline(v = 0.670348, col="red", lwd=3, lty=2)
abline(v = 0.82998, col="red", lwd=3, lty=2)
# 2a
plot(p, dnorm(p, 15, sqrt(2.5)), type = 'l')
# 2a
p2 = seq(10, 20, length = 100)
plot(p2, dnorm(p, 15, sqrt(2.5)), type = 'l')
p2
plot(p2, dnorm(p, 15, sqrt(2.5)), type = 'l')
plot(p2, dnorm(p2, 15, sqrt(2.5)), type = 'l')
# 2d
qnorm(.025, 14.9358, 0.9682)
qnorm(.975, 14.9358, 0.9682)
plot(p2, dnorm(p2, 14.9358, 0.9682), type='l')
abline(v = .14.9358)
abline(v = 13.03816, col="red", lwd=3, lty=2)
abline(v = 16.83344, col="red", lwd=3, lty=2)
abline(v = .14.9358)
plot(p2, dnorm(p2, 14.9358, 0.9682), type='l')
abline(v = 14.9358)
abline(v = 13.03816, col="red", lwd=3, lty=2)
abline(v = 16.83344, col="red", lwd=3, lty=2)
# Question 1
t.test(x, conf.level = 0.88)
# Question 1
t.test(1584, conf.level = 0.99)
# Question 1
qt(.99, 19)
# Question 1
qt(.995, 19)
# Question 2
c(25.2,21.3,22.8,17,29.8,21,25.5,16,20.9,19.5)
# Question 2
sample1 <- c(25.2,21.3,22.8,17,29.8,21,25.5,16,20.9,19.5)
mean(sample1)
sd(sample1)
qt(.975, 9)
# Question 3
sample2 <- c(.53, .65, .46, .50, .37)
# L: Residuals vs. Fitted Values Plot
sample2_residvfit <- autoplot(sample2, which = 1, ncol = 1, nrow = 1) +
theme(aspect.ratio = 1)
library(tidyverse)
library(ggfortify)
# Check Normality Assumption
# Normal Probability Plot
#   "qq plot"
sample2_qq <- autoplot(sample2, which = 2, ncol = 1, nrow = 1) +
theme(aspect.ratio = 1)
sample2_qq
qqnorm(sample2)
qqnorm(sample2)
qqline(sample2)
qqline(sample2)
qqnorm(sample2)
qqnorm(sample2)
qqnorm(sample2)
qqline(sample2)
# Question 4
sample2 <- c(.53, .65, .46, .50, .37)
mean(sample2)
sd(sample2)
qqnorm(sample2)
qqline(sample2)
mean(sample2)
sd(sample2)
qt(.975, 4)
pt(-2.1416, 4, .6)
pt(-2.1416, 4)
find_joint_p1 <- function(x, y){
solution1 <- ((y)^(x)) / (fact(x) * (1 + y + ((y^2)/2) + ((y^3)/6) + ((y^4)/24)))
}
find_joint_p1(1, 0.5)
find_joint_p1 <- function(x, y){
solution1 <- ((y)^(x)) / (factorial(x) * (1 + y + ((y^2)/2) + ((y^3)/6) + ((y^4)/24)))
}
find_joint_p1(1, 0.5)
print(find_joint_p1(1, 0.5))
x1 <- find_joint_p1(1, 0.5)
x1/10
x1 <- find_joint_p1(2, 0.5)
x1/10
x1 <- find_joint_p1(3, 0.5)
x1/10
x1 <- find_joint_p1(4, 0.5)
x1/10
x1 <- find_joint_p1(0, 1)
x1*(2/10)
x1 <- find_joint_p1(1, 1)
x1*(2/10)
x1 <- find_joint_p1(2, 1)
x1*(2/10)
x1 <- find_joint_p1(3, 1)
x1*(2/10)
x1 <- find_joint_p1(4, 1)
x1*(2/10)
x1 <- find_joint_p1(0, 2)
x1*(7/10)
x1 <- find_joint_p1(1, 2)
x1*(7/10)
x1 <- find_joint_p1(2, 2)
x1*(7/10)
x1 <- find_joint_p1(3, 2)
x1*(7/10)
x1 <- find_joint_p1(4, 2)
x1*(7/10)
find_joint_p1 <- function(x, y){
solution1 <- ((y)^(x)) / (factorial(x) * (1 + y + ((y^2)/2) + ((y^3)/6) + ((y^4)/24)))
}
x1 <- find_joint_p1(1, 0.5)
x1
x1 <- find_joint_p1(2, 0.5)
x1
x1 <- find_joint_p1(3, 0.5)
x1
x1 <- find_joint_p1(4, 0.5)
x1
x1*4
x1 <- find_joint_p1(3, 0.5)
x1
x1 <- find_joint_p1(2, 0.5)
x1
x1*2
x1 <- find_joint_p1(3, 0.5)
x1
x1*3
0.03791469 + 0.1516588 + 0.006319115 + 0.3033175
find_joint_p1 <- function(x, y){
solution1 <- ((y)^(x)) / (factorial(x) * (1 + y + ((y^2)/2) + ((y^3)/6) + ((y^4)/24)))
}
setwd("~/byu_fall_2023/Stat_348/STAT348/KaggleBikeShare/data")
install.packages('xgboost')
install.packages("rpart")
install.packages('ranger')
library(ranger)
library(tidymodels)
library(tidyverse)
library(vroom)
install.packages('stacks')
library(stacks)
library(xgboost)
install.packages("rpart")
install.packages('ranger')
library(ranger)
library(tidymodels)
library(tidyverse)
library(vroom)
install.packages("rpart")
install.packages("ranger")
rf_mod <- rand_forest(mtry = tune(),
min_n = tune(),
trees = 800) %>%
set_engine('ranger') %>% # What R function to use
set_mode('regression')
data_train <- vroom("train.csv") # grab training data
data_train <- data_train %>%
select(-casual, - registered) # drop casual and registered variables
log_train_set <- data_train %>%
mutate(count=log(count))
log_train_set
bike_recipe <- recipe(count ~ ., data=log_train_set) %>%
step_mutate(weather=ifelse(weather==4, 3, weather)) %>% #Change weather 4 to 3
step_mutate(weather=factor(weather, levels=1:3, labels=c("Sunny", "Mist", "Rain"))) %>% # change weather as factor INSIDE RECIPE
step_mutate(season=factor(season, levels=1:4, labels=c("Spring", "Summer", "Fall", "Winter"))) %>% # convert season to factor with levels
step_mutate(holiday=factor(holiday, levels=c(0,1), labels=c("No", "Yes"))) %>% # convert holiday to factor
step_time(datetime, features="hour") %>% # this hourly variable will replace datetime %>%
step_year(datetime, features="year") %>% # year factor
step_month(datetime, features="month") %>% # month factor
step_rm(datetime)
bike_recipe <- recipe(count ~ ., data=log_train_set) %>%
step_mutate(weather=ifelse(weather==4, 3, weather)) %>% #Change weather 4 to 3
step_mutate(weather=factor(weather, levels=1:3, labels=c("Sunny", "Mist", "Rain"))) %>% # change weather as factor INSIDE RECIPE
step_mutate(season=factor(season, levels=1:4, labels=c("Spring", "Summer", "Fall", "Winter"))) %>% # convert season to factor with levels
step_mutate(holiday=factor(holiday, levels=c(0,1), labels=c("No", "Yes"))) %>% # convert holiday to factor
step_time(datetime, features="hour") %>% # this hourly variable will replace datetime %>%
step_year(datetime, features="year") %>% # year factor
step_rm(datetime)
rf_mod <- rand_forest(mtry = tune(),
min_n = tune(),
trees = 800) %>%
set_engine('ranger') %>% # What R function to use
set_mode('regression')
data_train <- vroom("train.csv") # grab training data
data_train <- data_train %>%
select(-casual, - registered) # drop casual and registered variables
log_train_set <- data_train %>%
mutate(count=log(count))
log_train_set
bike_recipe <- recipe(count ~ ., data=log_train_set) %>%
step_mutate(weather=ifelse(weather==4, 3, weather)) %>% #Change weather 4 to 3
step_mutate(weather=factor(weather, levels=1:3, labels=c("Sunny", "Mist", "Rain"))) %>% # change weather as factor INSIDE RECIPE
step_mutate(season=factor(season, levels=1:4, labels=c("Spring", "Summer", "Fall", "Winter"))) %>% # convert season to factor with levels
step_mutate(holiday=factor(holiday, levels=c(0,1), labels=c("No", "Yes"))) %>% # convert holiday to factor
step_time(datetime, features="hour") %>% # this hourly variable will replace datetime %>%
step_year(datetime, features="year") %>% # year factor
step_rm(datetime)
bike_recipe <- recipe(count ~ ., data=log_train_set) %>%
step_mutate(weather=ifelse(weather==4, 3, weather)) %>% #Change weather 4 to 3
step_mutate(weather=factor(weather, levels=1:3, labels=c("Sunny", "Mist", "Rain"))) %>% # change weather as factor INSIDE RECIPE
step_mutate(season=factor(season, levels=1:4, labels=c("Spring", "Summer", "Fall", "Winter"))) %>% # convert season to factor with levels
step_mutate(holiday=factor(holiday, levels=c(0,1), labels=c("No", "Yes"))) %>% # convert holiday to factor
step_year(datetime, features="year") %>% # year factor
step_time(datetime, features="hour") %>% # this hourly variable will replace datetime %>%
step_rm(datetime)
bike_recipe <- recipe(count ~ ., data=log_train_set) %>%
step_mutate(weather=ifelse(weather==4, 3, weather)) %>% #Change weather 4 to 3
step_mutate(weather=factor(weather, levels=1:3, labels=c("Sunny", "Mist", "Rain"))) %>% # change weather as factor INSIDE RECIPE
step_mutate(season=factor(season, levels=1:4, labels=c("Spring", "Summer", "Fall", "Winter"))) %>% # convert season to factor with levels
step_mutate(holiday=factor(holiday, levels=c(0,1), labels=c("No", "Yes"))) %>% # convert holiday to factor
step_year(datetime, features="%Y") %>% # year factor
step_time(datetime, features="hour") %>% # this hourly variable will replace datetime %>%
step_rm(datetime)
bike_recipe <- recipe(count ~ ., data=log_train_set) %>%
step_mutate(weather=ifelse(weather==4, 3, weather)) %>% #Change weather 4 to 3
step_mutate(weather=factor(weather, levels=1:3, labels=c("Sunny", "Mist", "Rain"))) %>% # change weather as factor INSIDE RECIPE
step_mutate(season=factor(season, levels=1:4, labels=c("Spring", "Summer", "Fall", "Winter"))) %>% # convert season to factor with levels
step_mutate(holiday=factor(holiday, levels=c(0,1), labels=c("No", "Yes"))) %>% # convert holiday to factor
step_year(datetime, features="year") %>% # year factor
step_time(datetime, features="hour") %>% # this hourly variable will replace datetime %>%
step_rm(datetime)
bike_recipe <- recipe(count ~ ., data=log_train_set) %>%
step_mutate(weather=ifelse(weather==4, 3, weather)) %>% #Change weather 4 to 3
step_mutate(weather=factor(weather, levels=1:3, labels=c("Sunny", "Mist", "Rain"))) %>% # change weather as factor INSIDE RECIPE
step_mutate(season=factor(season, levels=1:4, labels=c("Spring", "Summer", "Fall", "Winter"))) %>% # convert season to factor with levels
step_mutate(holiday=factor(holiday, levels=c(0,1), labels=c("No", "Yes"))) %>% # convert holiday to factor
step_year(datetime, features="Year") %>% # year factor
step_time(datetime, features="hour") %>% # this hourly variable will replace datetime %>%
step_rm(datetime)
bike_recipe <- recipe(count ~ ., data=log_train_set) %>%
step_mutate(weather=ifelse(weather==4, 3, weather)) %>% #Change weather 4 to 3
step_mutate(weather=factor(weather, levels=1:3, labels=c("Sunny", "Mist", "Rain"))) %>% # change weather as factor INSIDE RECIPE
step_mutate(season=factor(season, levels=1:4, labels=c("Spring", "Summer", "Fall", "Winter"))) %>% # convert season to factor with levels
step_mutate(holiday=factor(holiday, levels=c(0,1), labels=c("No", "Yes"))) %>% # convert holiday to factor
step_year(datetime, features="year") %>% # year factor
step_time(datetime, features="hour") %>% # this hourly variable will replace datetime %>%
step_rm(datetime)
bike_recipe <- recipe(count ~ ., data=log_train_set) %>%
step_mutate(weather=ifelse(weather==4, 3, weather)) %>% #Change weather 4 to 3
step_mutate(weather=factor(weather, levels=1:3, labels=c("Sunny", "Mist", "Rain"))) %>% # change weather as factor INSIDE RECIPE
step_mutate(season=factor(season, levels=1:4, labels=c("Spring", "Summer", "Fall", "Winter"))) %>% # convert season to factor with levels
step_mutate(holiday=factor(holiday, levels=c(0,1), labels=c("No", "Yes"))) %>% # convert holiday to factor
step_time(datetime, features=c("hour","year")) %>% # this hourly variable will replace datetime %>%
step_rm(datetime)
bike_recipe <- recipe(count ~ ., data=log_train_set) %>%
step_mutate(weather=ifelse(weather==4, 3, weather)) %>% #Change weather 4 to 3
step_mutate(weather=factor(weather, levels=1:3, labels=c("Sunny", "Mist", "Rain"))) %>% # change weather as factor INSIDE RECIPE
step_mutate(season=factor(season, levels=1:4, labels=c("Spring", "Summer", "Fall", "Winter"))) %>% # convert season to factor with levels
step_mutate(holiday=factor(holiday, levels=c(0,1), labels=c("No", "Yes"))) %>% # convert holiday to factor
step_date(datetime, features = "year") %>%
step_time(datetime, features="hour") %>% # this hourly variable will replace datetime %>%
step_rm(datetime)
prepped_recipe <- prep(bike_recipe) # preprocessing new data
baked_data1 <- bake(prepped_recipe, new_data = log_train_set)
## Set Workflow
rforest_wf <- workflow() %>%
add_recipe(bike_recipe) %>%
add_model(rf_mod)
## Grid of values to tune over
tuning_grid <- grid_regular(mtry(range = c(1, 9)),
min_n(),
levels = 3) ## L^2 total tuning possibilities
baked_data1
rf_mod <- rand_forest(mtry = tune(),
min_n = tune(),
trees = 800) %>%
set_engine('ranger') %>% # What R function to use
set_mode('regression')
data_train <- vroom("train.csv") # grab training data
data_train <- data_train %>%
select(-casual, - registered) # drop casual and registered variables
log_train_set <- data_train %>%
mutate(count=log(count))
bike_recipe <- recipe(count ~ ., data=log_train_set) %>%
step_mutate(weather=ifelse(weather==4, 3, weather)) %>% #Change weather 4 to 3
step_mutate(weather=factor(weather, levels=1:3, labels=c("Sunny", "Mist", "Rain"))) %>% # change weather as factor INSIDE RECIPE
step_mutate(season=factor(season, levels=1:4, labels=c("Spring", "Summer", "Fall", "Winter"))) %>% # convert season to factor with levels
step_mutate(holiday=factor(holiday, levels=c(0,1), labels=c("No", "Yes"))) %>% # convert holiday to factor
step_date(datetime, features = "year") %>%
step_time(datetime, features="hour") %>% # this hourly variable will replace datetime %>%
step_rm(datetime) %>%
step_mutate(datetime_hour=factor(datetime_hour, levels = 0:23, labels = 0:23)) %>%
step_mutate(datetime_year=factor(datetime_year, levels = 2011, labels = 2011))
bike_recipe
prepped_recipe <- prep(bike_recipe) # preprocessing new data
baked_data1 <- bake(prepped_recipe, new_data = log_train_set)
baked_data1
## Set Workflow
rforest_wf <- workflow() %>%
add_recipe(bike_recipe) %>%
add_model(rf_mod)
## Grid of values to tune over
tuning_grid <- grid_regular(mtry(range = c(1, 9)),
min_n(),
levels = 3) ## L^2 total tuning possibilities
## Split data for CV
folds <- vfold_cv(data_train, v = 10, repeats=1) # k-fold CV
## Run the CV1
CV_results <- rforest_wf %>%
tune_grid(resamples=folds,
grid=tuning_grid,
metrics=metric_set(rmse, mae, rsq)) #Or leave metrics NULL
baked_data1
log_train_set['datetime']
log_train_set['datetime'].unique()
unique(log_train_set['datetime'])
view(log_train_set)
rf_mod <- rand_forest(mtry = tune(),
min_n = tune(),
trees = 800) %>%
set_engine('ranger') %>% # What R function to use
set_mode('regression')
data_train <- vroom("train.csv") # grab training data
data_train <- data_train %>%
select(-casual, - registered) # drop casual and registered variables
log_train_set <- data_train %>%
mutate(count=log(count))
bike_recipe <- recipe(count ~ ., data=log_train_set) %>%
step_mutate(weather=ifelse(weather==4, 3, weather)) %>% #Change weather 4 to 3
step_mutate(weather=factor(weather, levels=1:3, labels=c("Sunny", "Mist", "Rain"))) %>% # change weather as factor INSIDE RECIPE
step_mutate(season=factor(season, levels=1:4, labels=c("Spring", "Summer", "Fall", "Winter"))) %>% # convert season to factor with levels
step_mutate(holiday=factor(holiday, levels=c(0,1), labels=c("No", "Yes"))) %>% # convert holiday to factor
step_date(datetime, features = "year") %>%
step_time(datetime, features="hour") %>% # this hourly variable will replace datetime %>%
step_rm(datetime) %>%
step_mutate(datetime_hour=factor(datetime_hour, levels = 0:23, labels = 0:23)) %>%
step_mutate(datetime_year=factor(datetime_year, levels = 2011:2012, labels = c(2011, 2012)))
prepped_recipe <- prep(bike_recipe) # preprocessing new data
baked_data1 <- bake(prepped_recipe, new_data = log_train_set)
## Set Workflow
rforest_wf <- workflow() %>%
add_recipe(bike_recipe) %>%
add_model(rf_mod)
## Grid of values to tune over
tuning_grid <- grid_regular(mtry(range = c(1, 9)),
min_n(),
levels = 3) ## L^2 total tuning possibilities
## Split data for CV
folds <- vfold_cv(data_train, v = 10, repeats=1) # k-fold CV
## Run the CV1
CV_results <- rforest_wf %>%
tune_grid(resamples=folds,
grid=tuning_grid,
metrics=metric_set(rmse, mae, rsq)) #Or leave metrics NULL
## Find Best Tuning Parameters13
bestTune <- CV_results %>%
select_best("rmse")
## Finalize the Workflow & fit it1
final_rforest_wf <- rforest_wf %>%
finalize_workflow(bestTune) %>%
fit(data=log_train_set)
data_test <- vroom("test.csv") # input test data
final_log_lin_preds <- predict(final_rforest_wf, new_data = data_test) %>% #This predicts log(count)
mutate(.pred=exp(.pred)) %>% # Back-transform the log to original scale
bind_cols(., data_test) %>% #Bind predictions with test data
select(datetime, .pred) %>% #Just keep datetime and predictions
rename(count=.pred) %>% #rename pred to count (for submission to Kaggle)
mutate(count=pmax(0, count)) %>% #pointwise max of (0, prediction)
mutate(datetime=as.character(format(datetime))) #needed for right format to Kaggle
vroom_write(final_log_lin_preds, "bike_predictions_rforest2.csv", delim = ",")
################################################################################
# Bayesian Additive Regression Trees (BART)
library(parsnip)
library(bart)
library(dbarts)
install.packages('dbarts')
library(dbarts)
bart_mod <- bart(mode = 'regression',
engine = 'dbarts',
trees = 30)
bart_mod <- bart(mode = 'regression',
engine = 'dbarts',
trees = 30)
library(dbarts)
################################################################################
# Bayesian Additive Regression Trees (BART)
library(parsnip)
bart_mod <- bart(mode = 'regression',
engine = 'dbarts',
trees = 30)
library(parsnip::dbarts)
bart_mod <- parsnip::bart(mode = 'regression',
engine = 'dbarts',
trees = 30)
## Set Workflow
bart_wf <- workflow() %>%
add_recipe(bike_recipe) %>%
add_model(bart_mod)
## Set Workflow
bart_wf <- workflow() %>%
add_recipe(bike_recipe) %>%
add_model(bart_mod) %>%
fit(data=log_train_set)
data_test <- vroom("test.csv") # input test data
final_bart_preds <- predict(bart_wf, new_data = data_test) %>% #This predicts log(count)
mutate(.pred=exp(.pred)) %>% # Back-transform the log to original scale
bind_cols(., data_test) %>% #Bind predictions with test data
select(datetime, .pred) %>% #Just keep datetime and predictions
rename(count=.pred) %>% #rename pred to count (for submission to Kaggle)
mutate(count=pmax(0, count)) %>% #pointwise max of (0, prediction)
mutate(datetime=as.character(format(datetime))) #needed for right format to Kaggle
vroom_write(final_bart_preds, "bike_predictions_bart.csv", delim = ",")
